// NOTE: This will only produce probabilities of goal when the away team attacks while the home team homeends 
// A similar pcsp file will have to be generated from the home team POV to meaningfully compare which team has the higher chance of scoring during an attack

// Position of players in grid
// Left, LeftRight, and CenterLeft etc.
#define L 6;
#define LR 7;
#define CL 8;
#define C 9;
#define CR 10;
#define RL 11;
#define R 12;


#define HOME_TEAM 1123;
#define AWAY_TEAM 4435;

#define MAX_STEP 180;

// Grid of eligible positions that can receive the ball
// This will change based on the previous position and the action taken
// 1 means the position is eligible to receive the ball
// 0 means the position is not eligible to receive the ball
// See Individual Positions section for more info
var pos = [-1(6), 0, 0, 0, 1, 0, 0, 0, -1(6)];

// If the ball is in the air
var inAir = false;
var step = 0;

// Actions based on FIFA player ratings
// ShortPass, LongPass, LongShot, Finishing, Volley(air-borne strike), and Header
enum {SP, LP, LS, FI, VO, HD};

// Match URL: https://www.premierleague.com/match/12115

// Soccer field grid
// 1 means there is a player in that position
// 0 means there is no player in that position
// [-1 -1 -1 -1 -1 -1   L, LR, CL, C, CR, RL, R	   -1 -1 -1 -1 -1 -1]
var awayKepPos = [-1(6), 0,  0,  0, 1, 0,  0,  0, -1(6)];
var awayDefPos = [-1(6), 1,  0,  1, 0, 1,  0,  1, -1(6)];
var awayMidPos = [-1(6), 0,  1,  0, 1, 0,  1,  0, -1(6)];
var awayForPos = [-1(6), 0,  1,  0, 1, 0,  1,  0, -1(6)];

var homeKepPos = [-1(6), 0,  0,  0, 1, 0,  0,  0, -1(6)];
var homeDefPos = [-1(6), 1,  0,  1, 0, 1,  0,  1, -1(6)];
var homeMidPos = [-1(6), 1,  0,  1, 0, 1,  0,  1, -1(6)];
var homeForPos = [-1(6), 0,  0,  1, 0, 1,  0,  0, -1(6)];

var away_team_score=0;
var home_team_score=0;
/*
awayFor -> finishing(homePos[-2, +2], average of the three defending stats) -> goal
awayMid -> shortpass(homePos[-2, +2], average of the three defending stats) -> awayFor

homeDef -> tackle [] foul(aggression) -> penalty_kick(awayFor[finishing] vs homeKep)
*/

///////////// AWAY TEAM PLAYERS (Attacking Team) /////////////
// The parameters represent the probabilities specific to the player 
// The guard only allows eligible players to get the ball, see Individual Positions section for more info

// For example keepers can only ShortPass or LongPass
// Here 64, 64 represents the FIFA ShortPass and LongPass ratings for this particular player
AwayKepAtk = [pos[C] == 1]AwayKepPass(64, 64, 50, C);

AwayKepDef = AwayKepSave(71, C);

// Here for the defender, the first 3 parameters are with respect to the ShortPass, LongPass, and prob. to lose the ball respectively 
// The prob. to lose the ball for the attacking team's defender was calculated based on the defending team forward's player ratings 
// In particular, the probability to lose the ball was a weighted combination of the standing tackle, sliding tackle, and interception FIFA player ratings of the forwards
AwayDef = [pos[R ] == 1]AwayDefPass(73, 71, 38, R) []
		 [pos[CR] == 1]AwayDefPass(68, 63, 38, CR) [] 
		 [pos[CL] == 1]AwayDefPass(68, 63, 38, CL) [] 
		 [pos[L ] == 1]AwayDefPass(72, 59, 38, L);

// Similar to defender, midfielders and forwards have their own specific parameters
// See their processes below for more information on what those parameters are
// The prob. to lose for the attacking team's midfielders is based on the defending team's midfielders
// The prob. to lose for the attacking team's forwards is based on the defending team's defender
AwayMid = [pos[RL] == 1]AwayMidPass(79, 76, 74, 59, RL) [] 
		 [pos[C ] == 1]AwayMidPass(83, 80, 57, 59, C) [] 
		 [pos[LR] == 1]AwayMidPass(78, 73, 75, 59, LR);
	
		 //TODO: pass the penalty stat
AwayFor = [pos[RL] == 1]AwayForPass(77, 75, 74, 77, 75, 1, 1, 2, 3, 4, 5, 6, 7, RL) [] 
		 [pos[C ] == 1]AwayForPass(75, 73, 66, 76, 75,  1, 1, 2, 3, 4, 5, 6, 7,C) [] 
		 [pos[LR] == 1]AwayForPass(73, 65, 65, 69, 75,  1, 1, 2, 3, 4, 5, 6, 7,LR);

///////////// HOME TEAM PLAYERS (Defending Team) /////////////
// Home team defender, midfielders and forwards are already implicitly "defending:gk_handling, gk_*" via the prob. to lose the ball parameter

// the defending keeper is "Artur Boruc"
// gk_diving=82
// gk_handling=72
// gk_reflexes=83
// gk_speed=44
// gk_positioning=74
// average=71
// Note: gk_kicking only measures the goalkeeper's ability to kick the ball from
// out of the hands or on the ground

HomeKepAtk = [pos[C] == 1]HomeKepPass(64, 64, 50, C);

HomeKepDef = HomeKepSave(71, C);

HomeDef = [pos[R ] == 1]HomeDefPass(73, 71, 38, R) []
		 [pos[CR] == 1]HomeDefPass(68, 63, 38, CR) [] 
		 [pos[CL] == 1]HomeDefPass(68, 63, 38, CL) [] 
		 [pos[L ] == 1]HomeDefPass(72, 59, 38, L);
		 
HomeMid = [pos[RL] == 1]HomeMidPass(79, 76, 74, 59, RL) [] 
		 [pos[C ] == 1]HomeMidPass(83, 80, 57, 59, C) [] 
		 [pos[LR] == 1]HomeMidPass(78, 73, 75, 59, LR);

// Fill in stats
HomeFor = [pos[RL] == 1]HomeForPass(77, 75, 74, 77, 75, 1, 1, 2, 3, 4, 5, 6, 7,RL) [] 
		 [pos[C ] == 1]HomeForPass(75, 73, 66, 76, 75,  1, 1, 2, 3, 4, 5, 6, 7,C) [] 
		 [pos[LR] == 1]HomeForPass(73, 65, 65, 69, 75,  1, 1, 2, 3, 4, 5, 6, 7,LR);


///////////// Individual Positions /////////////
// There is a guard to every action (e.g., shortPass) a player can take
// The guard makes sure that there are players eligible to receive the ball should that action happen
// Furthermore, based on the type of action taken, only some players will be eligible to receive the ball
// E.g., If a defender at L does a shortPass, the midfielder at R should not be able to receive it
// The eligible players are updated with UpdatePos

/**
	AwayKep -> AwayKepPass -> AwayDef/HomeFor
	attacking_short_pass:
	skill_long_pass:
	aggregated_intercept: avg(intercept_score + 3 defending stat) by num_home_for
*/

AwayKepPass(attacking_short_pass, skill_long_pass, aggregated_intercept, position) = [
		awayDefPos[position-2] == 1 || 
		awayDefPos[position-1] == 1 ||
		awayDefPos[position  ] == 1 || 
		awayDefPos[position+1] == 1 || 
		awayDefPos[position+2] == 1
	]	shortPass -> pcase {
						attacking_short_pass: pass -> UpdatePos(position, SP); AwayDef
						aggregated_intercept: intercepted -> openPos(); HomeFor

					}
	[] // general choice
	[
		awayDefPos[position-6] == 1 ||
		awayDefPos[position-5] == 1 ||
		awayDefPos[position-4] == 1 ||
		awayDefPos[position-3] == 1 ||
		awayDefPos[position+3] == 1 ||
		awayDefPos[position+4] == 1 ||
		awayDefPos[position+5] == 1 ||
		awayDefPos[position+6] == 1
	]	longPass -> pcase {
						skill_long_pass: 		pass -> UpdatePos(position, LP); AwayDef // position(i) of making long pass
						aggregated_intercept: 	intercepted -> openPos(); HomeFor
					};

/**
	HomeKep -> HomeKepPass -> HomeDef/HomeFor
	attacking_short_pass:
	skill_long_pass:
	aggregated_intercept: avg(intercept_score + 3 defending stat) by num_home_for
*/
HomeKepPass(attacking_short_pass, skill_long_pass, aggregated_intercept, position) = [
		homeDefPos[position-2] == 1 || 
		homeDefPos[position-1] == 1 ||
		homeDefPos[position  ] == 1 || 
		homeDefPos[position+1] == 1 || 
		homeDefPos[position+2] == 1
	]	shortPass -> pcase {
						attacking_short_pass: pass -> UpdatePos(position, SP); HomeDef
						aggregated_intercept: intercepted -> openPos(); AwayFor

					}
	[] // general choice
	[
		homeDefPos[position-6] == 1 ||
		homeDefPos[position-5] == 1 ||
		homeDefPos[position-4] == 1 ||
		homeDefPos[position-3] == 1 ||
		homeDefPos[position+3] == 1 ||
		homeDefPos[position+4] == 1 ||
		homeDefPos[position+5] == 1 ||
		homeDefPos[position+6] == 1
	]	longPass -> pcase {
						skill_long_pass: 		pass -> UpdatePos(position, LP); HomeDef // position(i) of making long pass
						aggregated_intercept: 	intercepted -> openPos(); AwayFor
					};

/*
	AwayDef -> AwayDefPass -> AwayMid/HomeMid
	k: defending team forward's player ratings (weighted combination of the standing tackle, sliding tackle, and interception)
*/
AwayDefPass(attacking_short_pass, skill_long_pass, aggregated_intercept, position) = [
		awayMidPos[position-2] == 1 ||
		awayMidPos[position-1] == 1 ||
		awayMidPos[position  ] == 1 ||
		awayMidPos[position+1] == 1 ||
		awayMidPos[position+2] == 1
	]	shortPass -> pcase {
					attacking_short_pass: pass -> UpdatePos(position, SP); AwayMid
					aggregated_intercept: tackled -> openPos(); HomeMid
				}
	 [] // general choice
	[
		awayMidPos[position-6] == 1 ||
		awayMidPos[position-5] == 1 ||
		awayMidPos[position-4] == 1 ||
		awayMidPos[position-3] == 1 ||
		awayMidPos[position+3] == 1 ||
		awayMidPos[position+4] == 1 ||
		awayMidPos[position+5] == 1 ||
		awayMidPos[position+6] == 1
	]	longPass -> pcase {
					skill_long_pass: pass -> UpdatePos(position, LP); AwayMid
					aggregated_intercept: tackled -> openPos(); HomeMid
				};

HomeDefPass(attacking_short_pass, skill_long_pass, aggregated_intercept, position) = [
		homeMidPos[position-2] == 1 ||
		homeMidPos[position-1] == 1 ||
		homeMidPos[position  ] == 1 ||
		homeMidPos[position+1] == 1 ||
		homeMidPos[position+2] == 1
	]	shortPass -> pcase {
					attacking_short_pass: pass -> UpdatePos(position, SP); HomeMid
					aggregated_intercept: tackled -> openPos(); AwayMid
				}
	 [] // general choice
	[
		homeMidPos[position-6] == 1 ||
		homeMidPos[position-5] == 1 ||
		homeMidPos[position-4] == 1 ||
		homeMidPos[position-3] == 1 ||
		homeMidPos[position+3] == 1 ||
		homeMidPos[position+4] == 1 ||
		homeMidPos[position+5] == 1 ||
		homeMidPos[position+6] == 1
	]	longPass -> pcase {
					skill_long_pass: pass -> UpdatePos(position, LP); HomeMid
					aggregated_intercept: tackled -> openPos(); AwayMid
				};

/**
	AwayMid -> [ i:short pass | j:long pass  | k:long shot ] -> AwayFor
	l: defending team forward's midfielder ratings 
*/
AwayMidPass(attacking_short_pass, skill_long_pass, power_long_shot,aggregated_tackled, position) = [
		awayForPos[position-2] == 1 ||
		awayForPos[position-1] == 1 ||
		awayForPos[position  ] == 1	||
		awayForPos[position+1] == 1 ||
		awayForPos[position+2] == 1
	]	shortPass -> pcase {
						attacking_short_pass: pass -> UpdatePos(position, SP); AwayFor
						aggregated_tackled: tackled -> openPos(); HomeMid
					}
	 [] // general choice
	[
		 awayForPos[position-6] == 1 ||
		 awayForPos[position-5] == 1 ||
		 awayForPos[position-4] == 1 ||
		 awayForPos[position-3] == 1 ||
		 awayForPos[position+3] == 1 ||
		 awayForPos[position+4] == 1 ||
		 awayForPos[position+5] == 1 ||
		 awayForPos[position+6] == 1
	]	 longPass -> pcase {
						skill_long_pass: pass{inAir = true;} -> UpdatePos(position, LP); AwayFor
						aggregated_tackled: tackled  -> openPos(); HomeMid
					}
	 [] // general choice
	[
		 homeKepPos[C] == 1
	]	longShot -> pcase {
						power_long_shot: shoot -> UpdatePos(position, LS); HomeKepDef
						aggregated_tackled: tackled -> openPos(); HomeMid
					};

HomeMidPass(attacking_short_pass, skill_long_pass, power_long_shot,aggregated_tackled, position) = [
		homeForPos[position-2] == 1 ||
		homeForPos[position-1] == 1 ||
		homeForPos[position  ] == 1	||
		homeForPos[position+1] == 1 ||
		homeForPos[position+2] == 1
	]	shortPass -> pcase {
						attacking_short_pass: pass -> UpdatePos(position, SP); HomeFor
						aggregated_tackled: tackled -> openPos(); AwayMid
					}
	 [] // general choice
	[
		 homeForPos[position-6] == 1 ||
		 homeForPos[position-5] == 1 ||
		 homeForPos[position-4] == 1 ||
		 homeForPos[position-3] == 1 ||
		 homeForPos[position+3] == 1 ||
		 homeForPos[position+4] == 1 ||
		 homeForPos[position+5] == 1 ||
		 homeForPos[position+6] == 1
	]	 longPass -> pcase {
						skill_long_pass: pass{inAir = true;} -> UpdatePos(position, LP); HomeFor
						aggregated_tackled: tackled -> openPos(); AwayMid
					}
	 [] // general choice
	[
		 homeKepPos[C] == 1
	]	longShot -> pcase {
						power_long_shot: shoot -> UpdatePos(position, LS); AwayKepDef
						aggregated_tackled: tackled -> openPos(); AwayMid
					};

/**
	AwayFor -> [ i:finish | j:long shot | k:volley | l:header ] -> Defkep
	m: defending team defender player ratings 
*/
AwayForPass(i, j, k, l, m, p, a, b, c, d, e, f, g, position) = [
		homeKepPos[C] == 1
	]	finish -> pcase {
					i: shoot -> UpdatePos(position, FI); HomeKepDef
					m: tackled -> openPos(); HomeDef
					p: penalty -> AwaySimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	homeKepPos[C] == 1
	 ]	longShot -> pcase {
					j: shoot -> UpdatePos(position, LS); HomeKepDef
					m: tackled -> openPos(); HomeDef
					p: penalty -> AwaySimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	homeKepPos[C] == 1 && inAir == true
	 ]	volley -> pcase {
					k: shoot -> UpdatePos(position, VO); HomeKepDef
					m: tackled -> openPos(); HomeDef
					p: penalty -> AwaySimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	homeKepPos[C] == 1 && inAir == true
	 ]	header -> pcase {
					l: shoot -> UpdatePos(position, HD); HomeKepDef
					m: tackled -> openPos(); HomeDef
					p: penalty -> AwaySimulatePenaltyKick(a, b, c, d, e, f, g)
				};

HomeForPass(i, j, k, l, m, p, a, b, c, d, e, f, g, position) = [
		awayKepPos[C] == 1
	]	finish -> pcase {
					i: shoot -> UpdatePos(position, FI); AwayKepDef
					m: tackled -> openPos(); AwayDef
					p: penalty -> HomeSimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	awayKepPos[C] == 1
	 ]	longShot -> pcase {
					j: shoot -> UpdatePos(position, LS); AwayKepDef
					m: tackled -> openPos(); AwayDef
					p: penalty -> HomeSimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	awayKepPos[C] == 1 && inAir == true
	 ]	volley -> pcase {
					k: shoot -> UpdatePos(position, VO); AwayKepDef
					m: tackled -> openPos(); AwayDef
					p: penalty -> HomeSimulatePenaltyKick(a, b, c, d, e, f, g)
				}
	 [] // general choice
	 [
	 	awayKepPos[C] == 1 && inAir == true
	 ]	header -> pcase {
					l: shoot -> UpdatePos(position, HD); AwayKepDef
					m: tackled -> openPos(); AwayDef
					p: penalty -> HomeSimulatePenaltyKick(a, b, c, d, e, f, g)
				};

/**
	HomeKep -> [ i:attemptSave ] -> Skip
	End game after goal
*/
AwayKepSave(i, position) = attemptSave -> pcase {
								i: save -> UpdatePos(0, 0); AwayKepAtk
								100-i: concede{ home_team_score++ } -> Skip
							};

HomeKepSave(i, position) = attemptSave -> pcase {
								i: save -> UpdatePos(0, 0); HomeKepAtk
								100-i: concede{ away_team_score++ } -> Skip
							};


// we calculate the probability of a penalty kick happening using 0.25 * mentality_aggression of defender
// unfortunately, PAT3 doesn't like dot notation (i.e., `0.25`) so we'll have to use divide instead (i.e., `1/4`)
// lowest mentality_aggression in epl_ratings_20152016 = 9
// highest mentality_aggression in epl_ratings_20152016 = 94
//CheckIfPenaltyKick(mentality_aggression) = attacker_clash_with_defender -> pcase {
//	((1/4) * mentality_aggression): penalty_kick -> SimulatePenaltyKick(1,2,3,4,5,6,7/* dummy parameters */)
//	100 - ((1/4) * mentality_aggression): no_penalty_kick -> AwayKepSave(1,2/* dummy parameters*/)
//};

// there is `gk_speed` but no `goalkeeping_speed`
// => use the `gk_*` stats instead of the `goalkeeping_*` stats 
AwaySimulatePenaltyKick(
	mentality_penalties,
	skill_fk_accuracy,
	gk_diving,
	gk_handling,
	gk_reflexes,
	gk_speed,
	gk_positioning
) = penalty_kick -> pcase {
		// average away stat
		(mentality_penalties + skill_fk_accuracy) / 2: goal{ away_team_score++; } -> openPos(); HomeKepAtk
		// average gk stat
//		(gk_diving + gk_handling + gk_reflexes + gk_speed + gk_positioning) / 5: saved -> Skip
	};

//TODO set penalty kick to end game
HomeSimulatePenaltyKick(
	mentality_penalties,
	skill_fk_accuracy,
	gk_diving,
	gk_handling,
	gk_reflexes,
	gk_speed,
	gk_positioning
) = penalty_kick -> pcase {
		// average away stat
		(mentality_penalties + skill_fk_accuracy) / 2: goal{ home_team_score++;  } -> openPos(); AwayKepAtk
		// average gk stat
//		(gk_diving + gk_handling + gk_reflexes + gk_speed + gk_positioning) / 5: saved -> Skip
	};

/*
	params: current position, action
	return: update the position eligible to receive the ball
*/
openPos() = incStep{step++} -> setAllToOne {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 1; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip;

UpdatePos(position, e) = incStep{step++} -> case {
	position == L: 
		case {
			e == SP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 0; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
			e == LP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
	position == LR:
		case {
			e == SP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
			e == LP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 0; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
	position == CL: 
		case {
			e == SP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 1; pos[CR] = 1; pos[RL] = 0; pos[R] = 0;} -> Skip
			e == LP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 0; pos[CR] = 0; pos[RL] = 1; pos[R] = 1;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
	position == C:
		case {
			e == SP: {pos[L] = 0; pos[LR] = 1; pos[CL] = 1; pos[C] = 1; pos[CR] = 1; pos[RL] = 1; pos[R] = 0;} -> Skip
			e == LP: {pos[L] = 1; pos[LR] = 0; pos[CL] = 0; pos[C] = 0; pos[CR] = 0; pos[RL] = 0; pos[R] = 1;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}	
	position == CR:
		case {
			e == SP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 1; pos[C] = 1; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip
			e == LP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 0; pos[C] = 0; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
	position == RL:
		case {
			e == SP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip
			e == LP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 0; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
	default:
		case {
			e == SP: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 0; pos[CR] = 1; pos[RL] = 1; pos[R] = 1;} -> Skip
			e == LP: {pos[L] = 1; pos[LR] = 1; pos[CL] = 1; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
			default: {pos[L] = 0; pos[LR] = 0; pos[CL] = 0; pos[C] = 1; pos[CR] = 0; pos[RL] = 0; pos[R] = 0;} -> Skip
		}
};

// danger level: dist of ball to AwayKepPass
// #define Goal0 danger <= 0;
// #define Goal1 danger <= 1;
// #define Goal2 danger <= 2;
// #define Goal3 danger <= 3;
// #define Goal4 danger <= 4;
#define goal0 away_team_score == 1 && step <= MAX_STEP;
#assert AwayKepAtk reaches goal0 with prob;
#assert AwayKepAtk deadlockfree;

// G: Globally. has to hold on the entire subsequent path.
// F: Finally. eventually has to hold (somewhere on the subsequent path》
// #assert AwayKepAtk |= F G Goal0 with prob;
// #assert AwayKepAtk |= F G Goal1 with prob;
// #assert AwayKepAtk |= F G Goal2 with prob;
// #assert AwayKepAtk |= F G Goal3 with prob;
// #assert AwayKepAtk |= F G Goal4 with prob;